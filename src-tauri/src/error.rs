//! Unified error type for the giga-file-uploader application.
//!
//! All modules use `AppError` as the single error type, propagated via the `?` operator.
//! Display output uses English technical descriptions for logs and IPC error returns.
//! User-facing Chinese messages are generated by the frontend (L3 layer).

/// Unified application error type.
///
/// Each variant wraps a `String` description for flexibility and IPC serialization.
/// Tauri commands return `Result<T, String>` by converting via `.map_err(|e| e.to_string())`.
#[derive(Debug)]
pub enum AppError {
    /// Network request errors (e.g., reqwest failures, connection issues).
    Network(String),
    /// gigafile.nu API response errors (e.g., unexpected status codes, malformed responses).
    Api(String),
    /// Local storage read/write errors (e.g., tauri-plugin-store failures).
    Storage(String),
    /// File I/O errors (e.g., file not found, permission denied).
    Io(String),
    /// Internal logic errors (e.g., serialization failures, unexpected state).
    Internal(String),
}

impl std::fmt::Display for AppError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AppError::Network(msg) => write!(f, "Network error: {}", msg),
            AppError::Api(msg) => write!(f, "API error: {}", msg),
            AppError::Storage(msg) => write!(f, "Storage error: {}", msg),
            AppError::Io(msg) => write!(f, "IO error: {}", msg),
            AppError::Internal(msg) => write!(f, "Internal error: {}", msg),
        }
    }
}

impl std::error::Error for AppError {}

impl From<std::io::Error> for AppError {
    fn from(err: std::io::Error) -> Self {
        AppError::Io(err.to_string())
    }
}

impl From<reqwest::Error> for AppError {
    fn from(err: reqwest::Error) -> Self {
        AppError::Network(err.to_string())
    }
}

impl From<serde_json::Error> for AppError {
    fn from(err: serde_json::Error) -> Self {
        AppError::Internal(err.to_string())
    }
}

/// Convenience type alias for `std::result::Result<T, AppError>`.
pub type Result<T> = std::result::Result<T, AppError>;

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_display_network_error() {
        let err = AppError::Network("timeout".into());
        let display = err.to_string();
        assert!(
            display.contains("Network error"),
            "Expected 'Network error' in display output, got: {}",
            display
        );
        assert!(
            display.contains("timeout"),
            "Expected 'timeout' in display output, got: {}",
            display
        );
    }

    #[test]
    fn test_display_api_error() {
        let err = AppError::Api("status 500".into());
        let display = err.to_string();
        assert!(
            display.contains("API error"),
            "Expected 'API error' in display output, got: {}",
            display
        );
        assert!(
            display.contains("status 500"),
            "Expected 'status 500' in display output, got: {}",
            display
        );
    }

    #[test]
    fn test_from_io_error() {
        let io_err = std::io::Error::new(std::io::ErrorKind::NotFound, "file not found");
        let app_err = AppError::from(io_err);
        match &app_err {
            AppError::Io(msg) => assert!(
                msg.contains("file not found"),
                "Expected 'file not found' in message, got: {}",
                msg
            ),
            other => panic!("Expected AppError::Io, got: {:?}", other),
        }
    }

    #[test]
    fn test_from_serde_json_error() {
        let json_err = serde_json::from_str::<serde_json::Value>("invalid json").unwrap_err();
        let app_err = AppError::from(json_err);
        match &app_err {
            AppError::Internal(_) => {} // correct variant
            other => panic!("Expected AppError::Internal, got: {:?}", other),
        }
    }

    #[test]
    fn test_to_string_non_empty() {
        let variants: Vec<AppError> = vec![
            AppError::Network("net".into()),
            AppError::Api("api".into()),
            AppError::Storage("store".into()),
            AppError::Io("io".into()),
            AppError::Internal("internal".into()),
        ];
        for err in variants {
            let s = err.to_string();
            assert!(
                !s.is_empty(),
                "to_string() returned empty string for {:?}",
                err
            );
        }
    }

    #[test]
    fn test_question_mark_operator_propagation() {
        fn may_fail() -> Result<()> {
            let _: serde_json::Value = serde_json::from_str("invalid")?;
            Ok(())
        }
        let result = may_fail();
        assert!(result.is_err());
    }

    #[test]
    fn test_error_trait_is_implemented() {
        let err = AppError::Network("test".into());
        // Verify AppError implements std::error::Error by using it as a trait object.
        let _: &dyn std::error::Error = &err;
    }
}
