//! Upload data models for the giga-file-uploader application.
//!
//! Defines the lifecycle data models for file upload tasks: how files are split
//! into shards and chunks, and the status tracking for each level.
//! These models do NOT contain actual file data â€” only metadata for planning
//! and progress tracking.

use serde::{Deserialize, Serialize};

/// Upload configuration passed from the frontend via IPC.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct UploadConfig {
    /// Retention days: 3/5/7/14/30/60/100
    pub lifetime: u32,
}

/// Upload task status.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub enum UploadStatus {
    Pending,
    Uploading,
    Completed,
    Error,
}

/// Logical shard status.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub enum ShardStatus {
    Pending,
    Uploading,
    Completed,
    Error,
}

/// Upload chunk status.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub enum ChunkStatus {
    Pending,
    Uploading,
    Completed,
    Error,
}

/// Metadata for a single upload chunk (no actual file data).
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Chunk {
    /// Index within the parent shard (maps to API chunk parameter, 0-based).
    pub chunk_index: u32,
    /// Absolute byte offset in the original file (used for seek positioning).
    pub offset: u64,
    /// Byte count.
    pub size: u64,
    pub status: ChunkStatus,
}

/// Metadata for a logical shard.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Shard {
    pub shard_index: u32,
    /// Absolute byte offset in the original file.
    pub offset: u64,
    /// Byte count.
    pub size: u64,
    pub chunks: Vec<Chunk>,
    /// UUID v1 hex (32 chars), generated by upload_engine; chunk_manager sets to empty string.
    pub upload_id: String,
    pub status: ShardStatus,
    /// Download URL returned by the server after this shard is fully uploaded.
    pub download_url: Option<String>,
}

/// A single file upload task.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct UploadTask {
    pub task_id: String,
    pub file_name: String,
    pub file_path: String,
    pub file_size: u64,
    pub shards: Vec<Shard>,
    pub status: UploadStatus,
    /// File-level download URL (for single-shard files, same as shard URL).
    pub download_url: Option<String>,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_upload_config_construction_and_serde() {
        let config = UploadConfig { lifetime: 7 };
        assert_eq!(config.lifetime, 7);

        let json = serde_json::to_string(&config).unwrap();
        assert!(json.contains("\"lifetime\":7"));

        let deserialized: UploadConfig = serde_json::from_str(&json).unwrap();
        assert_eq!(deserialized.lifetime, 7);
    }

    #[test]
    fn test_upload_task_construction() {
        let task = UploadTask {
            task_id: "task-001".to_string(),
            file_name: "test.zip".to_string(),
            file_path: "/tmp/test.zip".to_string(),
            file_size: 1024,
            shards: vec![],
            status: UploadStatus::Pending,
            download_url: None,
        };
        assert_eq!(task.task_id, "task-001");
        assert_eq!(task.file_name, "test.zip");
        assert_eq!(task.file_path, "/tmp/test.zip");
        assert_eq!(task.file_size, 1024);
        assert!(task.shards.is_empty());
        assert_eq!(task.status, UploadStatus::Pending);
        assert!(task.download_url.is_none());
    }

    #[test]
    fn test_shard_construction() {
        let shard = Shard {
            shard_index: 0,
            offset: 0,
            size: 1024,
            chunks: vec![],
            upload_id: String::new(),
            status: ShardStatus::Pending,
            download_url: None,
        };
        assert_eq!(shard.shard_index, 0);
        assert_eq!(shard.offset, 0);
        assert_eq!(shard.size, 1024);
        assert!(shard.chunks.is_empty());
        assert_eq!(shard.upload_id, "");
        assert_eq!(shard.status, ShardStatus::Pending);
        assert!(shard.download_url.is_none());
    }

    #[test]
    fn test_chunk_construction() {
        let chunk = Chunk {
            chunk_index: 0,
            offset: 0,
            size: 512,
            status: ChunkStatus::Pending,
        };
        assert_eq!(chunk.chunk_index, 0);
        assert_eq!(chunk.offset, 0);
        assert_eq!(chunk.size, 512);
        assert_eq!(chunk.status, ChunkStatus::Pending);
    }

    #[test]
    fn test_upload_status_partial_eq() {
        assert_eq!(UploadStatus::Pending, UploadStatus::Pending);
        assert_eq!(UploadStatus::Uploading, UploadStatus::Uploading);
        assert_eq!(UploadStatus::Completed, UploadStatus::Completed);
        assert_eq!(UploadStatus::Error, UploadStatus::Error);
        assert_ne!(UploadStatus::Pending, UploadStatus::Uploading);
        assert_ne!(UploadStatus::Completed, UploadStatus::Error);
    }

    #[test]
    fn test_shard_status_partial_eq() {
        assert_eq!(ShardStatus::Pending, ShardStatus::Pending);
        assert_eq!(ShardStatus::Uploading, ShardStatus::Uploading);
        assert_eq!(ShardStatus::Completed, ShardStatus::Completed);
        assert_eq!(ShardStatus::Error, ShardStatus::Error);
        assert_ne!(ShardStatus::Pending, ShardStatus::Error);
    }

    #[test]
    fn test_chunk_status_partial_eq() {
        assert_eq!(ChunkStatus::Pending, ChunkStatus::Pending);
        assert_eq!(ChunkStatus::Uploading, ChunkStatus::Uploading);
        assert_eq!(ChunkStatus::Completed, ChunkStatus::Completed);
        assert_eq!(ChunkStatus::Error, ChunkStatus::Error);
        assert_ne!(ChunkStatus::Pending, ChunkStatus::Completed);
    }

    #[test]
    fn test_status_enums_serde_camel_case() {
        // UploadStatus
        let json = serde_json::to_string(&UploadStatus::Pending).unwrap();
        assert_eq!(json, "\"pending\"");
        let json = serde_json::to_string(&UploadStatus::Uploading).unwrap();
        assert_eq!(json, "\"uploading\"");
        let json = serde_json::to_string(&UploadStatus::Completed).unwrap();
        assert_eq!(json, "\"completed\"");
        let json = serde_json::to_string(&UploadStatus::Error).unwrap();
        assert_eq!(json, "\"error\"");

        // ShardStatus
        let json = serde_json::to_string(&ShardStatus::Pending).unwrap();
        assert_eq!(json, "\"pending\"");
        let json = serde_json::to_string(&ShardStatus::Uploading).unwrap();
        assert_eq!(json, "\"uploading\"");
        let json = serde_json::to_string(&ShardStatus::Completed).unwrap();
        assert_eq!(json, "\"completed\"");
        let json = serde_json::to_string(&ShardStatus::Error).unwrap();
        assert_eq!(json, "\"error\"");

        // ChunkStatus
        let json = serde_json::to_string(&ChunkStatus::Pending).unwrap();
        assert_eq!(json, "\"pending\"");
        let json = serde_json::to_string(&ChunkStatus::Uploading).unwrap();
        assert_eq!(json, "\"uploading\"");
        let json = serde_json::to_string(&ChunkStatus::Completed).unwrap();
        assert_eq!(json, "\"completed\"");
        let json = serde_json::to_string(&ChunkStatus::Error).unwrap();
        assert_eq!(json, "\"error\"");
    }

    #[test]
    fn test_status_enums_serde_roundtrip() {
        let status = UploadStatus::Uploading;
        let json = serde_json::to_string(&status).unwrap();
        let deserialized: UploadStatus = serde_json::from_str(&json).unwrap();
        assert_eq!(deserialized, status);

        let status = ShardStatus::Completed;
        let json = serde_json::to_string(&status).unwrap();
        let deserialized: ShardStatus = serde_json::from_str(&json).unwrap();
        assert_eq!(deserialized, status);

        let status = ChunkStatus::Error;
        let json = serde_json::to_string(&status).unwrap();
        let deserialized: ChunkStatus = serde_json::from_str(&json).unwrap();
        assert_eq!(deserialized, status);
    }

    #[test]
    fn test_upload_task_serde_camel_case_keys() {
        let task = UploadTask {
            task_id: "t1".to_string(),
            file_name: "a.txt".to_string(),
            file_path: "/a.txt".to_string(),
            file_size: 100,
            shards: vec![],
            status: UploadStatus::Pending,
            download_url: None,
        };
        let json = serde_json::to_string(&task).unwrap();
        assert!(json.contains("\"taskId\""));
        assert!(json.contains("\"fileName\""));
        assert!(json.contains("\"filePath\""));
        assert!(json.contains("\"fileSize\""));
        assert!(json.contains("\"downloadUrl\""));
    }
}
